# auto-updater Specification

## Purpose
TBD - created by archiving change add-version-management. Update Purpose after archive.
## 需求
### 需求：启动时更新检查

应用启动时必须自动检查更新，并在有新版本且安装包已就绪时提供视觉提示。

#### 场景：启动时自动检查

- **当** 应用启动完成后
- **那么** 必须在后台静默检查是否有新版本
- **并且** 检查过程不能阻塞应用启动
- **并且** 检查过程不能显示任何加载提示
- **并且** 如果检查失败，必须静默忽略（不提示用户）

#### 场景：发现新版本且安装包已就绪时显示菜单标记

- **当** 启动时检查发现有新版本
- **并且** 对应平台的安装包已在 Release 中就绪
- **那么** 必须在侧边栏的"关于"菜单项旁显示红色标记（红点或徽章）
- **并且** 红色标记必须持续显示直到用户查看关于页面
- **并且** 红色标记样式必须醒目但不突兀

#### 场景：发现新版本但安装包尚未就绪

- **当** 启动时检查发现有新版本
- **并且** 对应平台的安装包尚未在 Release 中就绪
- **那么** 不显示任何提示
- **并且** "关于"菜单项保持正常样式
- **并且** 行为与"已是最新版本"一致

#### 场景：已是最新版本

- **当** 启动时检查发现已是最新版本
- **那么** 不显示任何提示
- **并且** "关于"菜单项保持正常样式

---

### 需求：检查更新功能

应用必须提供检查更新功能，让用户能够发现并获取新版本。更新可用的判断条件为：存在更高版本号且对应平台的安装包已就绪。

#### 场景：手动检查更新

- **当** 用户在关于页面点击"检查更新"按钮
- **那么** 应用必须首先尝试通过 Tauri Updater 检查更新
- **并且** 如果 Tauri Updater 失败，必须通过 GitHub Releases API 获取最新版本信息
- **并且** 通过 GitHub API 检查时，必须同时验证 Release 资产中是否包含当前平台的安装包
- **并且** 仅当版本号更高且安装包已就绪时，才判定为"有更新可用"
- **并且** 如果版本号更高但安装包尚未就绪，必须显示"已是最新版本"
- **并且** 必须显示加载状态（如"正在检查..."）
- **并且** 如果有新版本且安装包已就绪，必须显示更新对话框
- **并且** 如果已是最新版本或安装包尚未就绪，必须显示"已是最新版本"提示
- **并且** 如果检查失败，必须显示友好的错误信息

#### 场景：网络错误处理

- **当** 检查更新时网络请求失败
- **那么** 必须显示"无法连接到更新服务器"错误
- **并且** 必须提供重试按钮
- **并且** 必须提供手动下载链接（指向 GitHub Releases 页面）

---

### 需求：下载更新功能

应用必须支持在应用内下载更新包。

#### 场景：开始下载更新

- **当** 用户在更新对话框点击"下载更新"按钮
- **那么** 应用必须开始后台下载更新包
- **并且** 必须显示下载进度条
- **并且** 必须显示已下载大小和总大小
- **并且** 必须显示下载速度
- **并且** 用户必须能够继续使用应用

#### 场景：下载进度更新

- **当** 更新包下载过程中
- **那么** 进度条必须实时更新
- **并且** 进度百分比必须准确反映下载状态
- **并且** 如果网络中断，必须提示并允许重试

#### 场景：取消下载

- **当** 用户点击"取消下载"按钮
- **那么** 必须立即停止下载
- **并且** 必须清理已下载的临时文件
- **并且** 必须恢复到检查更新状态

#### 场景：下载完成

- **当** 更新包下载完成
- **那么** 必须显示"下载完成"状态
- **并且** 必须显示"立即安装"按钮
- **并且** 必须显示"稍后安装"选项

---

### 需求：安装更新功能

应用必须支持安装已下载的更新包。

#### 场景：Windows 安装更新

- **当** 用户在 Windows 上点击"立即安装"
- **那么** 应用必须验证更新包签名
- **并且** 签名验证通过后，必须启动 NSIS 安装程序
- **并且** 安装程序必须以静默模式运行
- **并且** 当前应用必须退出以完成安装
- **并且** 安装完成后必须自动启动新版本

#### 场景：macOS 安装提示

- **当** 用户在 macOS 上点击"立即安装"
- **那么** 应用必须将 DMG 文件保存到用户下载目录
- **并且** 必须在 Finder 中显示该文件
- **并且** 必须显示安装指南对话框
- **并且** 指南必须说明"拖拽应用到 Applications 文件夹"
- **并且** 必须提供"打开安装文件"按钮

#### 场景：签名验证失败

- **当** 更新包签名验证失败
- **那么** 必须显示安全警告
- **并且** 必须阻止安装
- **并且** 必须建议用户从官方渠道下载
- **并且** 必须提供 GitHub Releases 链接

---

### 需求：更新清单配置

CI/CD 必须生成更新清单文件，供应用检查更新使用。

#### 场景：生成 latest.json

- **当** GitHub Actions 发布新版本
- **那么** 必须生成 `latest.json` 更新清单
- **并且** 清单必须包含版本号、发布日期、更新日志
- **并且** 清单必须包含各平台的下载 URL
- **并且** 清单必须包含各平台的签名
- **并且** 清单必须上传到 GitHub Releases

#### 场景：更新清单格式

- **当** 应用解析 latest.json
- **那么** JSON 结构必须符合 Tauri Updater 格式
- **并且** 必须包含 `version`、`notes`、`pub_date` 字段
- **并且** 必须包含 `platforms` 对象，键为平台标识符
- **并且** 每个平台必须包含 `signature` 和 `url` 字段

---

### 需求：更新包签名

所有更新包必须经过签名，确保来源可信。

#### 场景：构建时签名

- **当** CI/CD 构建更新包
- **那么** 必须使用私钥对更新包进行签名
- **并且** 必须生成 `.sig` 签名文件
- **并且** 私钥必须存储在 GitHub Secrets 中
- **并且** 签名必须使用 Ed25519 算法

#### 场景：应用端验证

- **当** 应用准备安装更新
- **那么** 必须使用公钥验证更新包签名
- **并且** 公钥必须内嵌在应用配置中
- **并且** 如果验证失败，必须拒绝安装

---

### 需求：NSIS 安装包支持

系统必须生成 NSIS 格式的 Windows 安装包，支持静默升级。

#### 场景：生成 NSIS 安装包

- **当** CI/CD 构建 Windows 版本
- **那么** 除了 MSI 格式外，必须同时生成 NSIS 格式安装包
- **并且** NSIS 包文件名格式为 `qsl-cardhub-v{version}-windows-{arch}-setup.exe`
- **并且** NSIS 包必须支持静默安装（`/S` 参数）
- **并且** NSIS 包必须支持覆盖安装（升级场景）

#### 场景：自动更新使用 NSIS

- **当** 应用执行自动更新
- **那么** 必须下载 NSIS 格式的安装包
- **并且** 必须以静默模式执行安装
- **并且** 安装完成后必须自动启动新版本

---

### 需求：阿里云 OSS 私有存储配置

CI/CD 必须将构建产物上传到阿里云私有 OSS Bucket，作为主要下载源。

#### 场景：创建私有 OSS Bucket

- **当** 首次配置阿里云存储时
- **那么** 必须创建一个专用的 OSS Bucket（如 `qsl-cardhub-releases`）
- **并且** 访问控制必须设置为私有（Private），禁止公开访问
- **并且** 仅允许阿里云 CDN 通过回源方式访问
- **并且** 启用 OSS 访问日志审计

#### 场景：配置 CDN 回源加速

- **当** OSS Bucket 创建完成后
- **那么** 必须配置阿里云 CDN，绑定自定义域名（如 `cdn.qsl-cardhub.com`）
- **并且** CDN 必须配置回源到私有 OSS Bucket
- **并且** CDN 必须启用 HTTPS（配置 SSL 证书）
- **并且** CDN 缓存规则必须缓存所有静态文件（.exe、.dmg、.sig、.json）
- **并且** CDN 缓存 TTL 必须设置为至少 7 天（减少回源请求）
- **并且** CDN 必须配置回源 Host 为 OSS Bucket 的内网域名

#### 场景：配置访问凭据

- **当** 需要在 CI/CD 中访问 OSS 时
- **那么** 必须在 GitHub Secrets 中配置以下凭据：
  - `ALIYUN_OSS_ACCESS_KEY_ID`：阿里云 AccessKey ID
  - `ALIYUN_OSS_ACCESS_KEY_SECRET`：阿里云 AccessKey Secret
  - `ALIYUN_OSS_BUCKET_NAME`：Bucket 名称
  - `ALIYUN_OSS_ENDPOINT`：OSS Endpoint（如 `oss-cn-hangzhou.aliyuncs.com`）
  - `ALIYUN_CDN_DOMAIN`：CDN 域名（如 `cdn.qsl-cardhub.com`）
- **并且** AccessKey 必须仅授予最小权限（OSS 上传权限）
- **并且** 凭据不得在代码中硬编码

---

### 需求：CI/CD 自动同步到阿里云

GitHub Actions 必须在发布新版本时自动将构建产物同步到阿里云 OSS。

#### 场景：安装 OSS 上传工具

- **当** CI/CD 开始构建时
- **那么** 必须安装阿里云官方 CLI 工具 `ossutil`
- **并且** 必须使用 GitHub Secrets 中的凭据配置 `ossutil`
- **并且** 必须验证配置是否成功（如执行 `ossutil ls` 列出 Bucket）

#### 场景：上传安装包到私有 OSS

- **当** 各平台构建完成后
- **那么** 必须将以下文件上传到 OSS：
  - Windows x64：`qsl-cardhub-v{version}-windows-x64-setup.exe` 和 `.sig` 文件
  - Windows ARM64：`qsl-cardhub-v{version}-windows-arm64-setup.exe` 和 `.sig` 文件
  - macOS ARM64：`qsl-cardhub-v{version}-macos-arm64.app.tar.gz` 和 `.sig` 文件、`.dmg` 文件
  - macOS x64：`qsl-cardhub-v{version}-macos-x64.app.tar.gz` 和 `.sig` 文件、`.dmg` 文件
- **并且** 文件必须上传到 `/releases/v{version}/` 目录
- **并且** 文件访问权限必须保持私有（不设置公共读）
- **并且** 上传失败时必须重试（最多 3 次）

#### 场景：并行上传优化

- **当** 上传到 GitHub Releases 和阿里云 OSS 时
- **那么** 两者必须并行执行，不互相阻塞
- **并且** 总发布时间增加不超过 2 分钟
- **并且** 如果阿里云上传失败，不影响 GitHub Releases 的发布（GitHub 作为备用源）

---

### 需求：生成阿里云 CDN 更新清单

CI/CD 必须生成包含阿里云 CDN URLs 的更新清单文件，作为主要更新清单。

#### 场景：生成 latest.json（CDN URLs）

- **当** 所有平台的安装包上传完成后
- **那么** 必须生成 `latest.json` 文件（包含阿里云 CDN URLs）
- **并且** 文件格式必须符合 Tauri Updater 规范
- **并且** 必须包含以下字段：
  - `version`：版本号
  - `notes`：更新日志
  - `pub_date`：发布日期
  - `platforms`：各平台的下载信息
- **并且** `platforms` 中每个平台必须包含：
  - `signature`：签名（与 GitHub 版本一致）
  - `url`：阿里云 CDN 下载 URL

#### 场景：阿里云 CDN URL 格式

- **当** 生成 `latest.json` 时
- **那么** URL 格式必须为：
  - `https://{CDN_DOMAIN}/releases/v{version}/{filename}`
  - 示例：`https://cdn.qsl-cardhub.com/releases/v0.6.2/qsl-cardhub-v0.6.2-windows-x64-setup.exe`
- **并且** 所有 URL 必须使用 HTTPS 协议
- **并且** 签名字段必须与 GitHub 版本的签名完全一致（因为文件内容相同）

#### 场景：上传 latest.json 到 OSS

- **当** `latest.json` 生成完成后
- **那么** 必须上传到 OSS 根目录（`/latest.json`）
- **并且** 文件访问权限必须保持私有（通过 CDN 回源访问）
- **并且** 可通过 `https://{CDN_DOMAIN}/latest.json` 访问（CDN 自动回源到 OSS）

---

### 需求：OSS 生命周期管理

阿里云 OSS 必须配置生命周期规则，自动清理旧版本文件以节省成本。

#### 场景：保留最近版本

- **当** 配置 OSS Bucket 时
- **那么** 必须设置生命周期规则：
  - 保留最近 3 个版本的所有文件
  - 自动删除超过 90 天的旧版本文件
- **并且** `latest.json` 永不过期（始终指向最新版本）
- **并且** 删除前必须有通知机制（如日志记录）

#### 场景：手动清理

- **当** 需要手动清理 OSS 存储时
- **那么** 必须提供清理脚本或文档说明
- **并且** 清理前必须确认不影响正在使用的版本
- **并且** 清理后必须验证 `latest.json` 仍然可用

---

### 需求：默认使用 CDN 更新检查

应用必须默认从阿里云 CDN 获取更新信息，失败时自动降级到 GitHub。

#### 场景：从 CDN 检查更新

- **当** 调用 `check_update()` 函数时
- **那么** 必须首先从阿里云 CDN 获取更新清单（`https://{CDN_DOMAIN}/latest.json`）
- **并且** 必须设置超时时间为 5 秒
- **并且** 必须解析 JSON 内容，提取以下字段：
  - `version`：最新版本号
  - `notes`：更新日志
  - `pub_date`：发布日期
  - `platforms.{platform}.url`：当前平台的下载 URL
  - `platforms.{platform}.signature`：当前平台的签名
- **并且** 必须根据当前操作系统和架构选择正确的平台：
  - macOS ARM64 → `darwin-aarch64`
  - macOS x64 → `darwin-x86_64`
  - Windows x64 → `windows-x86_64`
  - Windows ARM64 → `windows-aarch64`

#### 场景：CDN 检查失败（降级到 GitHub）

- **当** 从阿里云 CDN 获取更新清单失败（超时、网络错误、HTTP 错误等）时
- **那么** 必须记录日志（WARN 级别）：
  ```
  从 CDN 检查更新失败: {error}，降级到 GitHub Releases
  ```
- **并且** 必须自动切换到 GitHub Releases 获取更新清单
- **并且** GitHub URL 必须为：`https://github.com/HerbertGao/QSL-CardHub/releases/latest/download/latest.json`

#### 场景：比较版本号

- **当** 获取更新清单成功后（无论从哪个源）
- **那么** 必须比较最新版本号与当前应用版本号
- **并且** 如果最新版本 > 当前版本，返回更新信息（`Some(UpdateInfo)`）
- **并且** 如果最新版本 ≤ 当前版本，返回无更新（`None`）
- **并且** 版本比较必须正确处理语义化版本（如 `0.6.2` vs `0.6.10`）

---

### 需求：带降级的下载

应用必须优先从 CDN 下载更新包，失败时自动降级到 GitHub。

#### 场景：从 CDN 下载更新包

- **当** 调用 `download_update()` 函数时
- **那么** 必须首先尝试从更新清单中的 URL 下载（优先为 CDN URL）
- **并且** 必须显示下载进度（通过回调函数或事件）
- **并且** 必须记录日志（INFO 级别）：
  ```
  开始从 CDN 下载更新包: {url}
  ```

#### 场景：CDN 下载成功

- **当** 从 CDN 下载成功时
- **那么** 必须验证文件签名
- **并且** 如果签名验证通过，返回下载的文件路径
- **并且** 必须记录日志（INFO 级别）：
  ```
  从 CDN 下载成功，文件: {file_path}
  ```

#### 场景：CDN 下载失败（降级到 GitHub）

- **当** 从 CDN 下载失败（网络错误、超时、HTTP 错误等）时
- **那么** 必须记录日志（WARN 级别）：
  ```
  从 CDN 下载失败: {error}，降级到 GitHub Releases
  ```
- **并且** 必须自动从 GitHub Releases 获取更新清单（如果之前未获取）
- **并且** 必须从 GitHub URL 下载更新包
- **并且** 必须重置下载进度为 0

#### 场景：GitHub 下载成功

- **当** 从 GitHub 下载成功时
- **那么** 必须验证文件签名
- **并且** 如果签名验证通过，返回下载的文件路径
- **并且** 必须记录日志（INFO 级别）：
  ```
  从 GitHub 下载成功（备用源），文件: {file_path}
  ```

#### 场景：两个源都失败

- **当** CDN 和 GitHub 都下载失败时
- **那么** 必须返回错误
- **并且** 错误信息必须包含两个源的失败原因
- **并且** 必须记录日志（ERROR 级别）：
  ```
  所有下载源都失败: CDN: {cdn_error}, GitHub: {github_error}
  ```

#### 场景：签名验证失败

- **当** 下载成功但签名验证失败时
- **那么** 必须删除已下载的文件
- **并且** 必须返回错误（"签名验证失败，文件可能被篡改"）
- **并且** 必须记录日志（ERROR 级别）：
  ```
  下载的文件签名验证失败，拒绝安装: {source}
  ```
- **并且** 不尝试切换到备用源（因为签名相同，备用源也会失败）

---

### 需求：下载进度回调

下载过程必须支持进度回调，便于前端展示下载进度。

#### 场景：注册进度回调

- **当** 调用下载函数时
- **那么** 必须支持传入进度回调函数：
  ```rust
  pub fn download_update<F>(
      update_info: UpdateInfo,
      progress_callback: F,
  ) -> Result<PathBuf, Error>
  where
      F: Fn(u64, u64) + Send + 'static,
      // 参数: (已下载字节数, 总字节数)
  ```

#### 场景：实时更新进度

- **当** 下载过程中时
- **那么** 必须定期调用进度回调（如每下载 1MB 或每 500ms）
- **并且** 回调参数必须包含：
  - 已下载字节数（`downloaded_bytes: u64`）
  - 总字节数（`total_bytes: u64`）
- **并且** 前端可根据此信息计算进度百分比

#### 场景：切换源时重置进度

- **当** 从 CDN 切换到 GitHub 时
- **那么** 必须重置进度为 0
- **并且** 必须通过回调通知前端（`progress_callback(0, total_bytes)`）

---

### 需求：与现有 Tauri Updater 插件兼容

新的更新逻辑必须与现有 Tauri Updater 插件兼容。

#### 场景：保留 Tauri Updater 配置

- **当** 实现自定义更新逻辑时
- **那么** 必须保留 `tauri.conf.json` 中的 `updater` 配置
- **并且** 必须更新 `updater.endpoints` 指向阿里云 CDN：
  ```json
  "endpoints": [
    "https://cdn.qsl-cardhub.com/latest.json",
    "https://github.com/HerbertGao/QSL-CardHub/releases/latest/download/latest.json"
  ]
  ```
- **并且** Tauri Updater 插件会自动按顺序尝试这些 endpoints

#### 场景：签名验证使用相同公钥

- **当** 验证签名时
- **那么** 必须使用与 Tauri Updater 插件相同的公钥
- **并且** 公钥必须从 `tauri.conf.json` 的 `updater.pubkey` 字段读取
- **并且** 确保从 CDN 和 GitHub 下载的文件都可通过验证

