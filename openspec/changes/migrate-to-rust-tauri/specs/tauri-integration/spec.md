# Tauri 集成规范

## 目的

本规范定义了 QSL-CardHub Rust 版本的 Tauri 应用框架集成需求。Tauri 是一个用于构建跨平台桌面应用的框架，使用 Rust 作为后端、Web 技术作为前端。本规范确保 Tauri 应用正确初始化、前后端通信正常、窗口管理正确，以及构建和打包流程完善。

## 新增需求

### 需求:Tauri 应用初始化

系统必须正确初始化 Tauri 应用并配置所需的插件和权限。

#### 场景:应用启动

- **当** 用户运行 Tauri 应用
- **那么** 应用应在 500ms 内启动
- **并且** 应显示主窗口（800x600 像素）
- **并且** 窗口标题应为"QSL-CardHub"
- **并且** 应加载 Vue 3 前端界面

#### 场景:应用状态初始化

- **当** Tauri 应用启动时
- **那么** 应初始化 ProfileManager
- **并且** 应初始化 PrinterManager
- **并且** 应将管理器实例注册到 Tauri State
- **并且** 如果初始化失败，应显示错误对话框并退出

#### 场景:应用关闭

- **当** 用户关闭主窗口
- **那么** 应用应正常退出
- **并且** 应保存所有未保存的配置
- **并且** 应清理临时文件

### 需求:Tauri Commands API

系统必须提供完整的 Tauri Commands，供前端调用后端功能。

#### 场景:配置管理 Commands

- **当** 前端调用配置管理 Commands
- **那么** 应支持以下命令：
  - `get_profiles()` - 获取所有配置
  - `get_profile(id: String)` - 获取单个配置
  - `create_profile(name: String, printer_name: String)` - 创建配置
  - `update_profile(id: String, profile: Profile)` - 更新配置
  - `delete_profile(id: String)` - 删除配置
  - `set_default_profile(id: String)` - 设置默认配置
  - `export_profile(id: String)` - 导出配置
  - `import_profile(json: String)` - 导入配置
- **并且** 所有命令应返回 `Result<T, String>`
- **并且** 错误消息应使用中文

#### 场景:打印 Commands

- **当** 前端调用打印 Commands
- **那么** 应支持以下命令：
  - `get_printers()` - 获取打印机列表
  - `print_qsl(profile_id, callsign, serial, qty)` - 打印 QSL 卡片
  - `print_calibration(profile_id)` - 打印校准页
- **并且** 所有命令应返回 `Result<T, String>`
- **并且** 打印失败应返回详细错误信息

#### 场景:平台信息 Commands

- **当** 前端调用 `get_platform_info()`
- **那么** 应返回包含以下字段的对象：
  - `os`: "Windows" | "macOS" | "Linux"
  - `arch`: "x86_64" | "arm64" | 其他
- **并且** 检测应准确无误

#### 场景:批量数据获取

- **当** 前端调用 `get_initial_data()`
- **那么** 应返回包含以下字段的对象：
  - `profiles`: 所有配置列表
  - `default_profile_id`: 默认配置 ID
  - `platform`: 平台信息
  - `printers`: 打印机列表
- **并且** 一次调用获取所有初始化数据
- **并且** 减少前后端通信次数

### 需求:前后端通信

系统必须确保前后端通信稳定可靠。

#### 场景:异步调用

- **当** 前端使用 `invoke()` 调用 Tauri Command
- **那么** 应返回 Promise
- **并且** 成功时 resolve 返回值
- **并且** 失败时 reject 错误消息（String）

#### 场景:数据序列化

- **当** 前端传递复杂对象（如 Profile）
- **那么** Tauri 应使用 serde 自动反序列化
- **并且** 应验证所有必填字段
- **并且** 如果验证失败，应返回详细错误

#### 场景:错误处理

- **当** 后端返回错误
- **那么** 前端应捕获异常
- **并且** 错误消息应显示在 UI 中（ElMessage）
- **并且** 错误应记录到控制台

### 需求:窗口管理

系统必须正确管理应用窗口。

#### 场景:主窗口配置

- **当** 应用启动时
- **那么** 主窗口应符合以下配置：
  - 标题："QSL-CardHub"
  - 宽度：1200px
  - 高度：800px
  - 最小宽度：800px
  - 最小高度：600px
  - 居中显示
  - 可调整大小
  - 无需全屏模式

#### 场景:窗口状态持久化

- **当** 用户调整窗口大小或位置
- **那么** 应保存窗口状态到本地
- **并且** 下次启动时恢复窗口状态

### 需求:开发模式支持

系统必须支持开发模式以提高开发效率。

#### 场景:热重载

- **当** 开发者运行 `cargo tauri dev`
- **那么** 前端应启用 Vite 开发服务器
- **并且** 前端代码修改应自动重载
- **并且** Rust 代码修改应自动重新编译

#### 场景:开发者工具

- **当** 应用以开发模式运行
- **那么** 应自动打开浏览器开发者工具
- **并且** 应输出详细的日志信息

### 需求:构建和打包

系统必须支持生产环境的构建和打包。

#### 场景:生产构建

- **当** 开发者运行 `cargo tauri build`
- **那么** 应编译 Rust 代码为 release 模式
- **并且** 应构建前端为生产版本
- **并且** 应生成可执行文件

#### 场景:Windows 打包

- **当** 在 Windows 平台构建
- **那么** 应生成 `.exe` 可执行文件
- **并且** 应生成 `.msi` 安装包
- **并且** 可执行文件应包含应用图标
- **并且** 安装包应支持静默安装

#### 场景:macOS 打包

- **当** 在 macOS 平台构建
- **那么** 应生成 `.app` 应用包
- **并且** 应生成 `.dmg` 磁盘镜像
- **并且** 应用包应正确签名（如果配置了证书）

#### 场景:Linux 打包

- **当** 在 Linux 平台构建
- **那么** 应生成 `.AppImage` 文件
- **并且** 应生成 `.deb` 包（Debian/Ubuntu）
- **并且** AppImage 应可在所有主流发行版运行

#### 场景:可执行文件体积

- **当** 构建完成
- **那么** Windows 可执行文件应 < 20MB
- **并且** macOS 应用包应 < 25MB
- **并且** Linux AppImage 应 < 20MB
- **并且** 体积明显小于 Python 版（> 100MB）

### 需求:应用配置

系统必须通过 `tauri.conf.json` 正确配置应用。

#### 场景:应用元数据

- **当** 查看应用配置
- **那么** 应包含以下元数据：
  - productName: "QSL-CardHub"
  - version: "0.1.0"
  - identifier: "com.herbertgao.qsl-cardhub"
  - copyright: "© 2026 Herbert Software"

#### 场景:窗口配置

- **当** 配置主窗口
- **那么** 应设置默认尺寸、标题、最小尺寸
- **并且** 应禁用全屏模式
- **并且** 应启用窗口装饰

#### 场景:安全配置

- **当** 配置应用安全策略
- **那么** 应限制允许的 IPC 命令
- **并且** 应配置 CSP（Content Security Policy）
- **并且** 应禁用不必要的 Tauri API

### 需求:错误处理和日志

系统必须提供完善的错误处理和日志记录。

#### 场景:全局错误捕获

- **当** Rust 代码发生 panic
- **那么** 应捕获 panic 并显示友好错误对话框
- **并且** 应记录错误到日志文件
- **并且** 应用不应崩溃

#### 场景:日志记录

- **当** 应用运行时
- **那么** 应记录所有重要操作（配置变更、打印任务）
- **并且** 日志应保存到应用数据目录
- **并且** 日志应包含时间戳和级别（INFO、WARN、ERROR）

#### 场景:前端错误上报

- **当** 前端发生 JavaScript 错误
- **那么** 应通过 Tauri Command 上报到后端
- **并且** 后端应记录到日志文件
