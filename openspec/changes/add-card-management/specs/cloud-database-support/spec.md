# 规范：云数据库支持 (Phase 3)

## 新增需求

### 需求：数据存储模式选择

系统必须支持本地 SQLite 和云数据库两种存储模式，用户可自由选择。

#### 场景：默认使用本地 SQLite

- **当** 用户首次启动应用
- **那么** 系统必须默认使用本地 SQLite 模式
- **并且** 配置界面"存储模式"默认选中"本地 SQLite"
- **并且** 云数据库配置区域置灰不可编辑

#### 场景：切换到云数据库模式

- **当** 用户在配置界面选择"云数据库"模式
- **那么** 本地 SQLite 配置区域必须置灰不可编辑
- **并且** 云数据库配置区域必须启用
- **并且** 显示提示："切换到云数据库后，本地数据不会自动同步，请使用数据迁移功能"

#### 场景：保存存储模式配置

- **当** 用户选择存储模式并保存
- **那么** 系统必须将配置写入 `config/database.toml`
- **并且** 配置格式为：
  ```toml
  [database]
  mode = "sqlite"  # 或 "postgres"
  ```

---

### 需求：云数据库连接配置

系统必须提供云数据库连接配置界面，支持 PostgreSQL。

#### 场景：配置 PostgreSQL 连接

- **当** 用户选择云数据库模式
- **那么** 系统必须显示连接配置表单：
  - 数据库类型（下拉框）：PostgreSQL
  - 主机地址（文本输入框）
  - 端口（数字输入框，默认 5432）
  - 数据库名（文本输入框）
  - 用户名（文本输入框）
  - 密码（密码输入框）
  - SSL/TLS 连接（开关，默认关闭）

#### 场景：测试数据库连接

- **当** 用户点击"测试连接"按钮
- **那么** 系统必须使用填写的连接信息尝试连接数据库
- **并且** 如果连接成功，显示"连接成功"提示（绿色，3秒后自动消失）
- **并且** 如果连接失败，显示"连接失败: {错误原因}"提示（红色）
- **并且** 错误原因包括：
  - 主机不可达
  - 端口拒绝连接
  - 认证失败
  - 数据库不存在
  - SSL 不支持

#### 场景：SSL/TLS 连接

- **当** 用户勾选"SSL/TLS 连接"选项
- **那么** 系统必须使用 `sslmode=require` 连接
- **并且** 如果服务器不支持 SSL，连接失败时提示"服务器不支持 SSL 连接"

#### 场景：密码加密存储

- **当** 用户勾选"记住密码"并保存配置
- **那么** 系统必须使用凭据加密存储系统保存密码
- **并且** 存储键为：`qsl-cardhub:database:password`
- **并且** 密码不得明文存储（详见 **local-credential-storage** 规范）
- **并且** 读取密码时，从凭据存储系统获取并解密

#### 场景：配置文件格式

- **当** 用户保存云数据库配置
- **那么** 系统必须将配置写入 `config/database.toml`
- **并且** 格式为：
  ```toml
  [database]
  mode = "postgres"
  host = "db.example.com"
  port = 5432
  database = "qsl_cardhub"
  username = "qsl_user"
  ssl_mode = true
  remember_password = true
  ```
- **并且** 密码不得出现在配置文件中

---

### 需求：用户认证

系统必须支持用户注册和登录，获取 JWT Token 用于 API 认证。

#### 场景：用户注册

- **当** 用户在云数据库配置页面点击"注册账号"
- **那么** 系统必须打开注册表单弹窗
- **并且** 表单包含：用户名、邮箱、密码、确认密码
- **并且** 验证规则：
  - 用户名：3-50 个字符
  - 邮箱：符合标准格式（正则表达式验证）
  - 密码：至少 8 个字符
  - 确认密码：必须与密码一致
- **并且** 提交后，向云端发送注册请求
- **并且** 如果注册成功，自动填充用户名到配置表单

#### 场景：用户登录

- **当** 用户保存云数据库配置（包含用户名和密码）
- **那么** 系统必须向云端发送登录请求
- **并且** 请求格式为 `POST /auth/login`，body 为 `{ "username": "...", "password": "..." }`
- **并且** 如果登录成功，云端返回 JWT Token
- **并且** 系统必须将 Token 存储到内存中
- **并且** 如果用户勾选"保持登录"，可选择持久化存储
- **并且** 持久化时使用凭据加密存储系统，存储键为 `qsl-cardhub:auth:jwt_token`
- **并且** 后续所有 API 请求必须在 Header 中携带 `Authorization: Bearer {token}`

#### 场景：Token 自动刷新

- **当** JWT Token 即将过期（距离过期时间 < 5 分钟）
- **那么** 系统必须自动向云端发送刷新请求
- **并且** 请求格式为 `POST /auth/refresh`，Header 携带旧 Token
- **并且** 如果刷新成功，更新存储的 Token
- **并且** 如果刷新失败，清除 Token 并提示用户重新登录

#### 场景：登录失败处理

- **当** 登录请求返回 401 Unauthorized
- **那么** 系统必须显示"用户名或密码错误"提示
- **并且** 不得存储 Token
- **并且** 用户可以重新输入密码

---

### 需求：数据迁移

系统必须支持本地 SQLite 和云数据库之间的数据迁移。

#### 场景：从 SQLite 迁移到云数据库

- **当** 用户点击"从 SQLite 迁移到云数据库"按钮
- **那么** 系统必须首先验证云数据库连接
- **并且** 如果云数据库未配置或连接失败，提示"请先配置并测试云数据库连接"
- **并且** 如果连接成功，显示确认对话框：
  - "即将迁移 {N} 个项目和 {M} 条卡片到云数据库，是否继续？"
- **并且** 用户确认后，开始迁移：
  1. 读取本地 SQLite 所有项目数据
  2. 插入到云数据库 projects 表（owner_id 设为当前用户）
  3. 读取本地 SQLite 所有卡片数据
  4. 插入到云数据库 cards 表（creator_id 设为当前用户）
- **并且** 显示迁移进度（如"正在迁移卡片: 50/128"）
- **并且** 迁移完成后，提示"迁移成功，已切换到云数据库模式"
- **并且** 自动切换到云数据库模式

#### 场景：从云数据库下载到 SQLite

- **当** 用户点击"从云数据库下载到 SQLite"按钮
- **那么** 系统必须首先验证云数据库连接
- **并且** 显示确认对话框：
  - "即将下载云端数据到本地，本地现有数据将被覆盖，是否继续？"
  - 提供"备份本地数据"选项（勾选框）
- **并且** 如果用户勾选备份，创建本地数据库备份文件
- **并且** 用户确认后，开始下载：
  1. 清空本地 SQLite 数据
  2. 从云数据库下载当前用户的所有项目
  3. 从云数据库下载当前用户的所有卡片
  4. 插入到本地 SQLite
- **并且** 显示下载进度
- **并且** 下载完成后，提示"下载成功，已切换到本地 SQLite 模式"
- **并且** 自动切换到 SQLite 模式

#### 场景：迁移冲突处理

- **当** 迁移到云数据库时，发现云端已存在同名项目
- **那么** 系统必须提供冲突解决策略选择对话框：
  - 跳过（保留云端数据）
  - 覆盖（使用本地数据）
  - 合并（重命名本地项目，如"项目A (本地)"）
- **并且** 用户可选择"应用到所有冲突"选项
- **并且** 根据用户选择处理每个冲突

#### 场景：迁移失败回滚

- **当** 迁移过程中发生错误（网络中断、权限不足等）
- **那么** 系统必须停止迁移
- **并且** 回滚已迁移的数据（使用事务）
- **并且** 显示错误信息："迁移失败: {错误原因}"
- **并且** 不切换存储模式，保持原模式

---

### 需求：Repository 抽象层

系统必须提供数据库抽象层，统一 SQLite 和 PostgreSQL 的操作接口。

#### 场景：定义 Repository trait

- **当** 系统定义数据访问接口
- **那么** 必须定义 `ProjectRepository` trait：
  ```rust
  #[async_trait]
  pub trait ProjectRepository: Send + Sync {
      async fn create(&self, name: String) -> Result<Project>;
      async fn list(&self) -> Result<Vec<Project>>;
      async fn get(&self, id: &str) -> Result<Option<Project>>;
      async fn update(&self, id: &str, name: String) -> Result<Project>;
      async fn delete(&self, id: &str) -> Result<()>;
  }
  ```
- **并且** 同样定义 `CardRepository` trait

#### 场景：SQLite 实现 Repository

- **当** 使用本地 SQLite 模式
- **那么** 系统必须使用 `SqliteProjectRepository` 和 `SqliteCardRepository`
- **并且** 实现必须使用同步 `rusqlite` API（不需要 async）

#### 场景：PostgreSQL 实现 Repository

- **当** 使用云数据库模式
- **那么** 系统必须使用 `PostgresProjectRepository` 和 `PostgresCardRepository`
- **并且** 实现必须使用 async `tokio-postgres` 或 `sqlx` API
- **并且** 所有查询必须带 `WHERE owner_id = $1`（用户隔离）

#### 场景：配置驱动选择实现

- **当** 系统启动时
- **那么** 根据 `config/database.toml` 中的 `mode` 字段选择实现：
  - `mode = "sqlite"` → 使用 SQLite Repository
  - `mode = "postgres"` → 使用 PostgreSQL Repository
- **并且** 前端 Tauri 命令透明调用，不需要区分数据库类型

---

### 需求：多用户数据隔离

系统必须实现多用户数据隔离，每个用户只能访问自己的数据。

#### 场景：云数据库表结构扩展

- **当** 使用云数据库模式
- **那么** `projects` 表必须添加 `owner_id UUID` 字段
- **并且** `cards` 表必须添加 `creator_id UUID` 字段
- **并且** 创建索引：
  - `idx_projects_owner` ON projects(owner_id)
  - `idx_cards_creator` ON cards(creator_id)

#### 场景：查询项目列表（多用户隔离）

- **当** 用户查询项目列表
- **那么** PostgreSQL 查询必须包含 `WHERE owner_id = $1`
- **并且** `$1` 绑定为当前登录用户的 ID（从 JWT Token 解析）
- **并且** 不同用户的项目相互隔离，互不可见

#### 场景：查询卡片列表（多用户隔离）

- **当** 用户查询卡片列表
- **那么** PostgreSQL 查询必须 `JOIN projects` 并包含 `WHERE projects.owner_id = $1`
- **并且** 确保用户只能看到自己项目下的卡片

---

### 需求：错误处理和提示

系统必须正确处理云数据库相关的各类错误。

#### 场景：网络连接失败

- **当** 调用云数据库 API 时网络不可达
- **那么** 系统必须捕获网络错误
- **并且** 显示"网络连接失败，请检查网络设置"提示（黄色警告）
- **并且** 操作不应崩溃，提示用户稍后重试

#### 场景：Token 过期

- **当** API 返回 401 Unauthorized 错误
- **那么** 系统必须尝试刷新 Token
- **并且** 如果刷新失败，提示"登录已过期，请重新登录"
- **并且** 清除本地 Token
- **并且** 跳转到云端配置页面

#### 场景：数据库服务器不可用

- **当** 云数据库服务器返回 502/503/504 错误
- **那么** 系统必须显示"数据库服务器暂时不可用，请稍后重试"
- **并且** 记录错误日志

---

## 相关规范

- **card-management-core**（Phase 1）：卡片管理基础（依赖）
- **card-entry-and-management**（Phase 2）：卡片录入和管理（依赖）
- **local-credential-storage**（Phase 2）：本地凭据加密存储（用于安全存储数据库密码和 JWT Token）

## 技术约束

- **云数据库**：仅支持 PostgreSQL（MySQL 可后续添加）
- **认证协议**：JWT Token
- **服务端密码加密**：bcrypt
- **客户端密码存储**：使用凭据加密存储系统（详见 **local-credential-storage** 规范）
- **数据隔离**：基于 user_id 的行级隔离
- **迁移策略**：全量迁移，不支持增量同步
- **配置文件**：`config/database.toml`（不包含密码）

## 向后兼容性

- ✅ 无破坏性变更，新增功能
- ✅ Phase 1 + 2 的本地 SQLite 功能不受影响
- ✅ Repository 模式对前端透明，Tauri 命令接口不变
- ⚠️ 需要用户自行部署和维护云数据库
