# 设计文档：迁移版本号规则

## 版本号格式设计

### 新格式：`YYYY.M.D.NNN`

```
2026.1.23.001
│    │ │  └── 当日子版本号（001-999）
│    │ └───── 日期（1-31）
│    └─────── 月份（1-12）
└──────────── 年份
```

### 转换为整数

为了与 SQLite 的 `PRAGMA user_version`（32位整数）兼容，需要将版本号转换为整数：

```
2026.1.23.001 → 20260123001
```

转换公式：
```
version_int = YYYY * 10000000 + M * 1000000 / 10 + D * 1000 + NNN
```

简化为：
```
version_int = YYYYMMDD * 1000 + NNN
```

### 整数范围验证

- 最小版本：`2024.1.1.001` → `20240101001`
- 最大版本：`2099.12.31.999` → `20991231999`
- 32位有符号整数最大值：`2147483647`

**注意**：`20991231999` > `2147483647`，超出 32 位整数范围！

### 解决方案：使用 64 位版本号

SQLite 的 `user_version` 实际上可以存储 64 位整数（`INTEGER` 类型在 SQLite 中是可变长度的）。

或者，调整公式避免溢出：
```
version_int = (YYYY - 2020) * 10000000 + MMDD * 1000 + NNN
```

示例：
- `2026.1.23.001` → `6 * 10000000 + 123 * 1000 + 1` = `60123001`
- `2099.12.31.999` → `79 * 10000000 + 1231 * 1000 + 999` = `791231999`

这样可以安全地在 32 位整数范围内表示 2020-2099 年的版本。

## 解析逻辑

### 文件名格式

```
{YYYY}.{M}.{D}.{NNN}_{description}.sql
```

正则表达式：
```regex
^(\d{4})\.(\d{1,2})\.(\d{1,2})\.(\d{3})_.*\.sql$
```

### 向后兼容

同时支持旧格式：
```regex
^(\d{3})_.*\.sql$
```

旧格式版本号直接作为整数使用（1, 2, 3...），远小于新格式的版本号。

## 迁移整合策略

### 整合前

```
migrations/
├── 001_init.sql          # projects 表
├── 002_add_cards.sql     # cards 表
├── 003_add_sf_express.sql # sf_senders, sf_orders 表
├── 004_add_pay_method.sql # ALTER TABLE sf_orders ADD pay_method
└── 005_add_cargo_name.sql # ALTER TABLE sf_orders ADD cargo_name
```

### 整合后

```
migrations/
├── 2026.1.23.001_init.sql          # projects 表
├── 2026.1.23.002_add_cards.sql     # cards 表
└── 2026.1.23.003_add_sf_express.sql # sf_senders, sf_orders (含 pay_method, cargo_name)
```

### 已有数据库的兼容处理

对于已经使用旧版本号（1-5）的数据库：

1. 检测当前版本号是否为旧格式（< 1000）
2. 如果是旧格式且版本 >= 5，则视为已完成所有迁移
3. 将版本号更新为新格式的等效版本

或者更简单的方案：

- 旧版本号 1-5 对应的功能已包含在新的 `2026.1.23.001` - `2026.1.23.003` 中
- 新版本号 > 旧版本号，新迁移会自动执行
- 但这会导致重复执行！

**最终方案**：保留旧迁移文件，只添加新的迁移文件

```
migrations/
├── 001_init.sql              # 保留（旧）
├── 002_add_cards.sql         # 保留（旧）
├── 003_add_sf_express.sql    # 保留（旧）
├── 004_add_pay_method.sql    # 保留（旧）
├── 005_add_cargo_name.sql    # 保留（旧）
└── 2026.1.24.001_xxx.sql     # 新迁移使用新格式
```

这样可以：
- 旧数据库继续正常工作
- 新迁移使用新格式
- 无需处理版本号转换

## 结论

推荐采用"保留旧文件 + 新文件用新格式"的方案，理由：

1. **零风险**：不影响现有数据库
2. **简单实现**：只需扩展解析逻辑
3. **向前兼容**：新迁移使用更清晰的版本号
