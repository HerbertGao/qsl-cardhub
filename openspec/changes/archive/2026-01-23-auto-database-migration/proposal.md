# 提案：自动化数据库迁移机制

## 为什么

当前数据库迁移采用手动管理方式，存在以下问题：

1. **易遗漏**：添加新的迁移脚本后，需要手动更新 `CURRENT_DB_VERSION` 常量和 `get_migration_sql` 函数
2. **重复代码**：每次添加新迁移都需要修改两处代码
3. **易出错**：版本号和文件名需要手动保持一致，容易出现不匹配
4. **维护成本**：随着迁移脚本增多，match 分支会越来越长

## 变更内容

将手动管理迁移脚本改为自动扫描 `migrations/` 目录，根据文件名自动识别版本号并按顺序执行。

### 方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| A. 编译时嵌入 + 自动扫描 | 无运行时依赖、打包简单 | 需要构建脚本 |
| B. 运行时读取目录 | 实现简单 | 需要分发迁移文件 |
| C. 使用第三方库 (refinery) | 功能完善 | 增加依赖 |

**选择方案 A**：使用 `include_dir` 宏在编译时嵌入迁移文件，运行时自动扫描并按版本顺序执行。

## 设计要点

1. **文件命名规范**：`{版本号}_{描述}.sql`，如 `001_init.sql`
2. **版本号解析**：从文件名提取版本号，自动排序
3. **执行顺序**：按版本号升序执行
4. **版本记录**：使用 `PRAGMA user_version` 记录已执行的最高版本
5. **幂等性**：迁移脚本应使用 `IF NOT EXISTS` 确保可重复执行

## 影响范围

- **修改文件**
  - `src/db/sqlite.rs` - 重构迁移逻辑
  - `Cargo.toml` - 添加 `include_dir` 依赖

- **删除代码**
  - 移除 `CURRENT_DB_VERSION` 常量
  - 移除 `get_migration_sql` 函数中的手动映射

## 预期效果

- 添加新迁移只需创建 SQL 文件，无需修改 Rust 代码
- 自动识别迁移版本，自动按顺序执行
- 减少人为错误，提高开发效率
