# 规范：自动化数据库迁移

## 新增需求

### 需求：迁移文件自动发现

系统**必须**自动发现 `migrations/` 目录下的所有迁移脚本，无需手动在代码中注册。

#### 场景：添加新迁移文件

**给定** 在 `migrations/` 目录下添加了新文件 `004_add_feature.sql`
**当** 应用程序启动时
**则** 系统应该自动识别该迁移文件
**并且** 如果数据库版本低于 4，应该执行该迁移

#### 场景：迁移文件命名规范

**给定** 迁移文件名为 `{NNN}_{description}.sql` 格式
**当** 系统解析文件名时
**则** 应该正确提取版本号 NNN
**并且** 忽略不符合格式的文件

---

### 需求：迁移顺序执行

系统**必须**按版本号顺序执行迁移脚本。

#### 场景：多个待执行迁移

**给定** 数据库版本为 1
**并且** 存在迁移文件 002、003、004
**当** 执行迁移时
**则** 应该按 002 -> 003 -> 004 的顺序执行
**并且** 每执行完一个迁移，数据库版本应该更新

#### 场景：跳过已执行的迁移

**给定** 数据库版本为 3
**并且** 存在迁移文件 001、002、003、004
**当** 执行迁移时
**则** 应该只执行版本 4 的迁移
**并且** 版本 1、2、3 的迁移应该被跳过

---

### 需求：迁移错误处理

系统**必须**在迁移失败时保持数据库一致性。

#### 场景：迁移脚本执行失败

**给定** 数据库版本为 2
**并且** 版本 3 的迁移脚本包含语法错误
**当** 执行迁移时
**则** 数据库版本应该保持为 2
**并且** 应该记录错误日志
**并且** 应用程序应该报告迁移失败

#### 场景：无效文件名处理

**给定** `migrations/` 目录包含文件 `readme.txt`
**当** 系统扫描迁移文件时
**则** 应该忽略该文件
**并且** 不影响其他迁移文件的执行

---

### 需求：编译时嵌入

系统**必须**在编译时将迁移文件嵌入到二进制文件中。

#### 场景：分发简化

**给定** 应用程序已编译
**当** 分发应用程序时
**则** 只需要分发单个二进制文件
**并且** 不需要额外分发 migrations 目录

#### 场景：迁移文件完整性

**给定** 应用程序包含嵌入的迁移文件
**当** 应用程序启动时
**则** 应该能够访问所有编译时存在的迁移文件
**并且** 文件内容与源文件一致
