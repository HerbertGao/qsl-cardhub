## 上下文

当前卡片录入流程（`create_card()`）仅校验呼号格式和数量范围，不检查同项目下是否已存在相同呼号。数据库 `cards` 表也没有 `(project_id, callsign)` 的唯一约束。系统已有 `get_project_callsigns()` 函数返回项目下去重呼号列表，可复用于前端预加载。

## 目标 / 非目标

**目标：**
- 在同一项目内禁止录入重复呼号的卡片
- 前端即时反馈（输入时校验），后端兜底保障（INSERT 前查询）
- 连续录入模式下也能正确拦截重复呼号

**非目标：**
- 不清理历史重复数据
- 不添加数据库层 UNIQUE 约束（避免破坏已有数据）
- 不支持跨项目的呼号去重（不同项目允许同一呼号）

## 决策

### 决策 1：不使用数据库 UNIQUE 约束，使用应用层检查

**选择**：在 `create_card()` 中用 `SELECT EXISTS` 检查重复，而非添加 `UNIQUE(project_id, callsign)` 约束。

**理由**：数据库中可能已有重复数据，添加 UNIQUE 约束需要先清理历史数据，风险较高。应用层检查对新录入生效即可。

**替代方案**：
- 添加 UNIQUE 约束 + 迁移脚本清理重复 → 风险高，可能丢数据
- 使用 `INSERT ... ON CONFLICT IGNORE` → 静默忽略不符合需求，用户需要明确的错误提示

### 决策 2：前端使用预加载 Set 而非异步校验

**选择**：项目切换时调用已有的 `get_project_callsigns()` 加载到 `Set<string>`，输入时本地比对。

**理由**：
- 已有现成接口，无需新增后端 API
- 本地比对零延迟，体验更好
- 呼号数据量有限（单个项目通常不超过数千条），内存开销可忽略

**替代方案**：
- 每次输入都请求后端校验 → 延迟高，需防抖，体验差
- 仅后端校验，前端不做 → 用户需等到提交才知道重复，体验差

### 决策 3：连续录入成功后本地追加而非重新加载

**选择**：连续录入成功后执行 `set.add(callsign)`，不重新请求 `get_project_callsigns()`。

**理由**：避免不必要的网络请求，`add` 操作是幂等的且即时生效。

## 风险 / 权衡

- **[并发录入]** 多窗口同时录入同一项目时，前端 Set 可能不同步 → 后端 `SELECT EXISTS` 兜底，最终一致性有保障
- **[历史数据]** 已有重复数据不受影响，但新录入一个已存在的重复呼号也会被拒绝 → 这是预期行为，与"只对新录入生效"不矛盾（已有记录存在 = 该呼号已被占用）
- **[大项目性能]** 项目下呼号很多时预加载 Set 可能较慢 → 实际场景中单项目呼号数量有限，可接受
