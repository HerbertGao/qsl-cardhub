# 规范：本地凭据加密存储 (Phase 2+3)

## 新增需求

### 需求：凭据存储方式

系统必须提供安全的本地凭据存储机制,支持多种敏感信息的加密存储。

#### 场景：使用系统钥匙串（优先）

- **当** 系统需要存储敏感信息
- **那么** 系统必须优先尝试使用操作系统钥匙串
- **并且** 使用 `keyring` crate 进行跨平台钥匙串访问
- **并且** 支持的系统钥匙串:
  - macOS: Keychain
  - Windows: Credential Manager
  - Linux: Secret Service API (GNOME Keyring / KWallet)
- **并且** 存储键必须使用统一命名格式: `qsl-cardhub:{category}:{item}`

#### 场景：系统钥匙串不可用时降级

- **当** 系统钥匙串不可用（如 Linux 无桌面环境）
- **那么** 系统必须降级使用本地加密文件存储
- **并且** 加密文件路径为: `{app_data_dir}/credentials/keystore.enc`
- **并且** 必须显示警告提示: "系统钥匙串不可用,使用本地加密文件存储"

#### 场景：检测钥匙串可用性

- **当** 应用首次启动
- **那么** 系统必须检测系统钥匙串是否可用
- **并且** 尝试写入测试项 `qsl-cardhub:test:probe`
- **并且** 如果写入成功,标记钥匙串可用
- **并且** 如果写入失败,标记钥匙串不可用并启用降级模式
- **并且** 删除测试项

---

### 需求：本地加密文件存储

系统必须在钥匙串不可用时提供安全的本地加密文件存储。

#### 场景：生成加密密钥

- **当** 首次使用本地加密文件存储
- **那么** 系统必须生成随机主密钥（256位）
- **并且** 使用 PBKDF2 派生加密密钥:
  - 盐值（Salt）: 从设备唯一标识符派生（machine-id）
  - 迭代次数: 100,000 次
  - 输出长度: 256 位
- **并且** 主密钥存储在受保护的内存中,不写入磁盘

#### 场景：加密存储数据

- **当** 需要存储敏感信息到本地文件
- **那么** 系统必须使用 AES-256-GCM 加密算法
- **并且** 为每条数据生成随机 Nonce（96位）
- **并且** 数据格式为:
  ```json
  {
    "version": 1,
    "entries": {
      "qrz.cn:username": {
        "nonce": "base64编码的nonce",
        "ciphertext": "base64编码的密文",
        "tag": "base64编码的认证标签"
      }
    }
  }
  ```
- **并且** 加密文件权限必须设置为 `0600`（仅所有者可读写）

#### 场景：读取加密数据

- **当** 需要读取存储的敏感信息
- **那么** 系统必须使用主密钥解密数据
- **并且** 验证认证标签（GCM tag）
- **并且** 如果验证失败,返回错误 "数据已损坏或被篡改"
- **并且** 如果解密成功,返回明文数据

#### 场景：更新加密数据

- **当** 需要更新已存储的敏感信息
- **那么** 系统必须读取整个加密文件
- **并且** 解密并更新对应的条目
- **并且** 重新加密整个数据结构
- **并且** 原子性写入文件（先写临时文件,再重命名）

---

### 需求：QRZ.cn 凭据存储

系统必须安全存储 QRZ.cn 登录凭据。

#### 场景：存储 QRZ.cn 用户名

- **当** 用户保存 QRZ.cn 登录凭据
- **那么** 系统必须存储用户名到配置文件 `config/qrz.toml`
- **并且** 用户名明文存储（非敏感信息）
- **并且** 配置格式为:
  ```toml
  [qrz]
  username = "BI1UTG"
  ```

#### 场景：存储 QRZ.cn 密码（默认记住）

- **当** 用户保存 QRZ.cn 登录凭据
- **那么** 系统必须使用凭据存储系统加密保存密码
- **并且** 存储键为: `qsl-cardhub:qrz.cn:password`
- **并且** 密码不得出现在配置文件中
- **并且** 无需用户勾选"记住密码",默认总是保存

#### 场景：存储 QRZ.cn Cookie

- **当** QRZ.cn 登录成功获取 Cookie
- **那么** 系统必须将 CFID 和 CFTOKEN 存储到应用状态（内存）
- **并且** Cookie 格式为:
  ```rust
  struct QrzSession {
      cfid: String,
      cftoken: String,
      expires_at: DateTime<Utc>, // 推测过期时间：30天后
  }
  ```
- **并且** Cookie 仅在内存中存储,应用关闭后丢弃
- **并且** 下次启动时重新登录获取新 Cookie

#### 场景：自动填充 QRZ.cn 密码

- **当** 用户打开 QRZ.cn 配置页面
- **并且** `config/qrz.toml` 中存在用户名
- **那么** 系统必须从凭据存储中读取密码
- **并且** 如果密码存在,自动填充到密码输入框
- **并且** 密码输入框显示为遮罩（不显示明文）

#### 场景：清除 QRZ.cn 凭据

- **当** 用户点击"清除凭据"按钮并确认
- **那么** 系统必须从凭据存储中删除密码
- **并且** 从配置文件中删除用户名配置
- **并且** 清除内存中的 Cookie

---

### 需求：云数据库凭据存储

系统必须安全存储云数据库连接凭据（Phase 3）。

#### 场景：存储数据库连接信息

- **当** 用户保存云数据库配置
- **那么** 系统必须将非敏感信息存储到 `config/database.toml`
- **并且** 配置格式为:
  ```toml
  [database]
  mode = "postgres"
  host = "db.example.com"
  port = 5432
  database = "qsl_cardhub"
  username = "qsl_user"
  ssl_mode = true
  remember_password = true
  ```
- **并且** 密码不得出现在配置文件中

#### 场景：存储数据库密码

- **当** 用户勾选"记住密码"并保存云数据库配置
- **那么** 系统必须使用凭据存储系统加密保存密码
- **并且** 存储键为: `qsl-cardhub:database:password`
- **并且** 密码不得明文存储

#### 场景：存储 JWT Token

- **当** 用户登录云端成功获取 JWT Token
- **那么** 系统必须将 Token 存储到内存中
- **并且** 如果用户勾选"保持登录",可选择持久化存储 Token
- **并且** 持久化存储时使用凭据存储系统
- **并且** 存储键为: `qsl-cardhub:auth:jwt_token`
- **并且** Token 格式为:
  ```rust
  struct JwtSession {
      access_token: String,
      refresh_token: String,
      expires_at: DateTime<Utc>,
  }
  ```

#### 场景：自动填充数据库密码

- **当** 用户打开云数据库配置页面
- **并且** `config/database.toml` 中 `remember_password = true`
- **那么** 系统必须从凭据存储中读取密码
- **并且** 自动填充到密码输入框

#### 场景：清除云数据库凭据

- **当** 用户取消勾选"记住密码"
- **那么** 系统必须从凭据存储中删除密码和 Token
- **并且** 更新配置文件 `remember_password = false`

---

### 需求：凭据访问控制

系统必须控制凭据的访问权限和使用范围。

#### 场景：凭据访问日志

- **当** 系统读取或写入凭据
- **那么** 必须记录访问日志（调试模式）
- **并且** 日志格式为:
  ```
  [2026-01-22 10:30:45] CREDENTIAL_READ: qsl-cardhub:qrz.cn:password
  [2026-01-22 10:31:20] CREDENTIAL_WRITE: qsl-cardhub:database:password
  ```
- **并且** 日志不得包含凭据内容
- **并且** 生产模式下日志仅记录失败操作

#### 场景：凭据过期检查

- **当** 读取 Cookie 或 Token 类型的凭据
- **那么** 系统必须检查过期时间
- **并且** 如果已过期,自动删除并返回 None
- **并且** 提示用户重新登录

#### 场景：凭据存储错误处理

- **当** 凭据存储操作失败（权限不足、磁盘已满等）
- **那么** 系统必须返回明确的错误信息
- **并且** 错误类型包括:
  - `KeyringNotAvailable`: 系统钥匙串不可用
  - `PermissionDenied`: 文件权限不足
  - `DiskFull`: 磁盘空间不足
  - `CorruptedData`: 数据已损坏
  - `DecryptionFailed`: 解密失败
- **并且** 向用户显示友好的错误提示

---

## 相关规范

- **qrz-cn-integration** (Phase 2): QRZ.cn 登录配置（使用本规范存储凭据）
- **cloud-database-support** (Phase 3): 云数据库支持（使用本规范存储凭据）
- **configuration-management**: 配置管理（非敏感配置文件管理）

## 技术约束

- **钥匙串库**: `keyring` crate (v2.0+)
- **加密算法**: AES-256-GCM
- **密钥派生**: PBKDF2-HMAC-SHA256, 100,000 迭代
- **加密文件路径**: `{app_data_dir}/credentials/keystore.enc`
- **文件权限**: Unix 0600 / Windows 仅所有者访问
- **存储键命名**: `qsl-cardhub:{category}:{item}`
- **支持的凭据类型**:
  - QRZ.cn 密码: `qsl-cardhub:qrz.cn:password`
  - 数据库密码: `qsl-cardhub:database:password`
  - JWT Token: `qsl-cardhub:auth:jwt_token`

## 安全约束

- ❌ **禁止明文存储**: 任何密码、Token 不得明文存储
- ❌ **禁止日志记录**: 日志中不得出现凭据内容
- ❌ **禁止网络传输**: 主密钥不得通过网络传输
- ✅ **内存保护**: 敏感数据使用后应立即清零
- ✅ **原子写入**: 加密文件更新必须原子性操作
- ✅ **降级安全**: 降级模式仍需加密,不得明文

## 向后兼容性

- ✅ 无破坏性变更,新增功能
- ✅ 旧版本无凭据存储,首次使用时初始化
- ✅ 跨平台兼容（macOS、Windows、Linux）
- ⚠️ Linux 无桌面环境时使用降级模式
